<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArchLinuxでCLI開発環境を整える</title>
    <url>/posts/54214/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h1 id="CLI環境を作る"><a href="#CLI環境を作る" class="headerlink" title="CLI環境を作る"></a>CLI環境を作る</h1><h2 id="起動時にCLIが立ち上がるための設定"><a href="#起動時にCLIが立ち上がるための設定" class="headerlink" title="起動時にCLIが立ち上がるための設定"></a>起動時にCLIが立ち上がるための設定</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/default/grub</span><br></pre></td></tr></table></figure>
<p><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;</code>に<code>text</code>を追加。<br>起動時に、スプラッシュスクリーン(通常はディストリビューションのロゴなど)を表示したい人は、<code>splash</code>を追加できる。</p>
<ul>
<li><code>/etc/default/grub</code>ファイルの変更をGRUBブートローダーに反映</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<ul>
<li>現状、システム起動のデフォルトターゲットに何が指定されているのかを知る</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl get-default</span><br></pre></td></tr></table></figure>
<p>通常、GUI環境を使用している場合は、<code>graphical.target</code>と表示され、そしてそれは、<code>multi-user.target</code>を包含している。しかし、CLI環境オンリーで十分だという人にとっては、システム起動時間の短縮やリソース効率の向上の観点から、デフォルトターゲットを<code>multi-user.target</code>に切り替えることをおすすめできる。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li>GUI環境に戻したいときは</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>
<ul>
<li>日本語の表示、入力にすぐれたターミナルエミュレータをインストールする<br>以下、fbtermでの実装で失敗した。まず、多くのデスクトップ環境で使われているibusとfbtermを連携させるのに必要なibus-mozcをAURパッケージからyayコマンドでインストールするはずが、ビルドに失敗する。また、kmsconでの日本語表示には、成功しているため、以降、土台をkmsconに置く。</li>
</ul>
<h2 id="kmscon"><a href="#kmscon" class="headerlink" title="kmscon"></a>kmscon</h2><p><code>kmscon</code>はUnicode&#x2F;UTF-8 互換で動くので日本語表示ができる。</p>
<h3 id="kmsconのインストール"><a href="#kmsconのインストール" class="headerlink" title="kmsconのインストール"></a>kmsconのインストール</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S kmscon</span><br></pre></td></tr></table></figure>

<h3 id="日本語フォントをインストール"><a href="#日本語フォントをインストール" class="headerlink" title="日本語フォントをインストール"></a>日本語フォントをインストール</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S ttf-dejavu otf-ipafont</span><br></pre></td></tr></table></figure>

<h3 id="フォントを適用"><a href="#フォントを適用" class="headerlink" title="フォントを適用"></a>フォントを適用</h3><p><code>/etc/fonts/conf.d/99-kmscon.conf</code><br>私は、フォントにNerdFontの<code>Agave</code>を使っているので、以下のようになる。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;</span><br><span class="line">&lt;fontconfig&gt;</span><br><span class="line">&lt;match&gt;</span><br><span class="line">  &lt;test name=&quot;family&quot;&gt;&lt;string&gt;monospace&lt;/string&gt;&lt;/test&gt;</span><br><span class="line">  &lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;strong&quot;&gt;</span><br><span class="line">    &lt;string&gt;Agave Nerd Font Mono&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;DejaVu Sans Mono&lt;/string&gt;</span><br><span class="line">    &lt;string&gt;IPAGothic&lt;/string&gt;</span><br><span class="line">  &lt;/edit&gt;</span><br><span class="line">&lt;/match&gt;</span><br><span class="line">&lt;/fontconfig&gt;</span><br></pre></td></tr></table></figure>

<h3 id="キーボードレイアウトを設定"><a href="#キーボードレイアウトを設定" class="headerlink" title="キーボードレイアウトを設定"></a>キーボードレイアウトを設定</h3><p><code>/etc/kmscon/kmscon.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xkb-layout=jp</span><br></pre></td></tr></table></figure>

<h3 id="tty2以降をkmsconに設定"><a href="#tty2以降をkmsconに設定" class="headerlink" title="tty2以降をkmsconに設定"></a>tty2以降をkmsconに設定</h3><p>あとで、<code>kmsconvt@tty3.service</code>を作るため、スキップしてもよい。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /usr/lib/systemd/system/kmsconvt\@.service /etc/systemd/system/autovt\@.service</span><br></pre></td></tr></table></figure>
<ul>
<li><code>kmsconvt@.service</code>を有効化<br><code>autovt@tty3.service</code> は <code>kmsconvt@.service</code> へのシンボリックリンクなため、元のサービスを有効化することで、<code>autovt@tty3.service</code> も間接的に有効になる。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> kmsconvt@tty3.service</span><br></pre></td></tr></table></figure>

<h3 id="kmsconをtty3にセットする"><a href="#kmsconをtty3にセットする" class="headerlink" title="kmsconをtty3にセットする"></a>kmsconをtty3にセットする</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># テンプレートサービスを別名でコピー</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /usr/lib/systemd/system/kmsconvt@.service /etc/systemd/system/kmsconvt@tty3.service</span><br></pre></td></tr></table></figure>
<h3 id="kmscon（tty）上で日本語入力を可能にする"><a href="#kmscon（tty）上で日本語入力を可能にする" class="headerlink" title="kmscon（tty）上で日本語入力を可能にする"></a>kmscon（tty）上で日本語入力を可能にする</h3><p>以下、uimでmozcを使用する設定</p>
<ul>
<li>インストール</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S uim</span><br></pre></td></tr></table></figure>
<p><code>~/.uim</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define default-im-name &#x27;mozc)</span><br><span class="line">(define-key generic-on-key? &#x27;(&quot;&lt;Control&gt; &quot;))</span><br><span class="line">(define-key generic-off-key? &#x27;(&quot;&lt;Control&gt; &quot;))</span><br></pre></td></tr></table></figure>
<p>あとは、以下を<code>~/.bashrc</code>などに書けばOK</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uim-fep</span><br></pre></td></tr></table></figure>
<p>これにより、Ctrl+Spaceキーで日本語入力の切り替えが可能になる。</p>
<ul>
<li>参考<br>kmscon<br><a href="https://www.kaias1jp.com/entry/2021/01/11/173542">https://www.kaias1jp.com/entry/2021/01/11/173542</a><br><a href="https://qiita.com/Pseudonym/items/9ff0e9028dfd6bad5958">https://qiita.com/Pseudonym/items/9ff0e9028dfd6bad5958</a><br><del>fbterm<br><a href="https://qiita.com/Pseudonym/items/12e447557a5234bb265b">https://qiita.com/Pseudonym/items/12e447557a5234bb265b</a></del></li>
</ul>
<h2 id="CLI環境で使えるツール一覧"><a href="#CLI環境で使えるツール一覧" class="headerlink" title="CLI環境で使えるツール一覧"></a>CLI環境で使えるツール一覧</h2><ul>
<li>コマンドラインでGeminiと話せるツール<br><a href="https://github.com/greycodee/gemini-terminal">https://github.com/greycodee/gemini-terminal</a><br><a href="https://github.com/eliben/gemini-cli">https://github.com/eliben/gemini-cli</a></li>
<li>コマンドラインでDiscordが使えるツール<br><a href="https://github.com/ayn2op/discordo">https://github.com/ayn2op/discordo</a></li>
</ul>
<h2 id="discordoをCLI環境で使えるようにする"><a href="#discordoをCLI環境で使えるようにする" class="headerlink" title="discordoをCLI環境で使えるようにする"></a>discordoをCLI環境で使えるようにする</h2><p>何度か試行したが、できなかった。<br><del>まず、discordトークンは、機密情報なので、libsecretかgnome-keyringかkwalletを使用したい。<br>GUIではアンロックは容易だが、CLIでのキーリングのアンロックがサポートされていないシークレットサービスも少なくない。<br>ということで、まずは、CLI上でキーリングをアンロックし、discordoでログインできるかどうかを確認する必要がある。<code>opensc</code>パッケージに同封されている<code>pkcs11-tool</code>よりCLIでのアンロックを試したが、あれは、<code>gnome-keyring</code>で使えるようなものだった。CLIでは<code>gnome-keyring-daemon</code>が起動できないため、失敗に終わった。</del></p>
]]></content>
      <tags>
        <tag>ArchLinux, CLI, 開発環境</tag>
      </tags>
  </entry>
  <entry>
    <title>WSLを使わない! Windows開発環境構築</title>
    <url>/posts/47392/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h1 id="WSLないないのWindows開発環境構築"><a href="#WSLないないのWindows開発環境構築" class="headerlink" title="WSLないないのWindows開発環境構築"></a>WSLないないのWindows開発環境構築</h1><h2 id="コメント"><a href="#コメント" class="headerlink" title="コメント"></a>コメント</h2><p>こちらの記事は、主に、CLI環境で開発していきたいという方にすごく向いているかと思う。</p>
<h2 id="ターミナルのアップデート"><a href="#ターミナルのアップデート" class="headerlink" title="ターミナルのアップデート"></a>ターミナルのアップデート</h2><p>まずは、今回の主役、ターミナルpwsh(powershell)をアップデート<br><a href="https://github.com/PowerShell/PowerShell/releases/">https://github.com/PowerShell/PowerShell/releases/</a><br>Latestの安定版をインストール<br>ダウンロードするときに、arm64かx64か、どれをダウンロードすればいいかわからない場合は、アーキテクチャーを調べよう。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msinfo32</span><br></pre></td></tr></table></figure>
<p>システムの種類が<code>x64ベース PC</code>であれば、<br>x64のmsiのインストーラーをダウンロード &amp; 実行すればよい。</p>
<h2 id="sudoの有効化"><a href="#sudoの有効化" class="headerlink" title="sudoの有効化"></a>sudoの有効化</h2><p>システム＞開発者向けより、sudoの有効化<br>LinuxなどUNIX系では、<code>sudo</code>を用いるのが習慣だ。</p>
<h2 id="パッケージマネジャーのインストール"><a href="#パッケージマネジャーのインストール" class="headerlink" title="パッケージマネジャーのインストール"></a>パッケージマネジャーのインストール</h2><p>以下、Ubuntuなら<code>apt</code>, ArchLinuxなら、<code>pacman</code>など、パッケージマネジャーによって、ソフトのダウンロードを高速化するために必要だ。<br>私は、<code>chocolatey</code>を使う。<br><a href="https://chocolatey.org/">https://chocolatey.org/</a></p>
<p>以下のコマンドでインストールが可能だ。</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://community.chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="chocolateyによる各種ソフトインストール"><a href="#chocolateyによる各種ソフトインストール" class="headerlink" title="chocolateyによる各種ソフトインストール"></a>chocolateyによる各種ソフトインストール</h2><p>以下、管理者モードで実行するように<br>ripgrepは、nvimの<a href="https://github.com/nvim-telescope/telescope.nvim">Telescope</a>プラグインの階層文字列検索を使用するときに必要になるので、合わせてダウンロードしておきたい。開発中のGit操作はすべて<a href="https://github.com/jesseduffield/lazygit">lazygit</a>で行う。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sudo choco install ripgrep lazygit starship vim neovim git wget unzip nvm -y</span><br></pre></td></tr></table></figure>

<h2 id="各種ソフトの設定"><a href="#各種ソフトの設定" class="headerlink" title="各種ソフトの設定"></a>各種ソフトの設定</h2><p>neovimで、LSP機能を使いたい人は、私の場合だと、<a href="https://github.com/williamboman/mason-lspconfig.nvim">mason-lspconfig</a>を使用していて、各言語のLSPサーバーをダウンロードしてくるのに、pythonやnpmを使用することが多い。<br>ゆえに、python, npmをWindowsにインストールしておこう。  </p>
<h3 id="pythonのダウンロード（任意）"><a href="#pythonのダウンロード（任意）" class="headerlink" title="pythonのダウンロード（任意）"></a>pythonのダウンロード（任意）</h3><p>以下より、最新のpythonを公式よりダウンロード &gt;&gt; EXE実行<br><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<h3 id="nvmによるnpm-nodeのインストール"><a href="#nvmによるnpm-nodeのインストール" class="headerlink" title="nvmによるnpm/nodeのインストール"></a>nvmによるnpm/nodeのインストール</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nvm install <span class="number">22</span>.<span class="number">12</span>.<span class="number">0</span></span><br><span class="line">nvm use <span class="number">22</span>.<span class="number">12</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="starshipをターミナルに適用"><a href="#starshipをターミナルに適用" class="headerlink" title="starshipをターミナルに適用"></a>starshipをターミナルに適用</h3><p>以下、<a href="https://starship.rs/guide/">https://starship.rs/guide/</a> を要約したもの</p>
<ul>
<li>pwshに適用する場合</li>
</ul>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line">vim <span class="variable">$PROFILE</span></span><br><span class="line"><span class="comment"># 以下追加</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> (&amp;starship init powershell)</span><br><span class="line"></span><br><span class="line"><span class="comment"># コマンド一行で行うには</span></span><br><span class="line"><span class="built_in">Invoke-Expression</span> (&amp;starship init powershell <span class="literal">--print-full-init</span> | <span class="built_in">Out-String</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>cmdに適用する場合<br><a href="https://chrisant996.github.io/clink/clink.html">https://chrisant996.github.io/clink/clink.html</a></li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">winget install clink</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#%LocalAppData%\clink\starship.lua</span><br><span class="line"></span><br><span class="line">load(io.popen(&#x27;starship init cmd&#x27;):read(&quot;*a&quot;))()</span><br></pre></td></tr></table></figure>

<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$env:LOCALAPPDATA</span></span><br><span class="line">mkdir <span class="literal">-p</span> .config</span><br><span class="line"><span class="built_in">cd</span> .config</span><br><span class="line"><span class="built_in">wget</span> https://raw.githubusercontent.com/verazza/dotfiles/master/.config/starship.toml</span><br></pre></td></tr></table></figure>

<h3 id="vimの設定"><a href="#vimの設定" class="headerlink" title="vimの設定"></a>vimの設定</h3><ul>
<li>_vimrcを配置<br>私の場合、<a href="https://github.com/verazza/dotfiles">dotfiles</a>にドットファイルをまとめているので、以下のコマンドで済む。</li>
</ul>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">wget</span> https://raw.githubusercontent.com/verazza/dotfiles/master/.vimrc</span><br><span class="line"><span class="built_in">move</span> .vimrc _vimrc</span><br><span class="line">mkdir <span class="literal">-p</span> ~/.wsl</span><br><span class="line"><span class="built_in">cd</span> ~/.wsl/</span><br><span class="line"><span class="built_in">wget</span> https://raw.githubusercontent.com/verazza/dotfiles/master/.wsl/.vimrc</span><br></pre></td></tr></table></figure>

<h4 id="win32yank"><a href="#win32yank" class="headerlink" title="win32yank"></a>win32yank</h4><p><a href="https://github.com/equalsraf/win32yank">https://github.com/equalsraf/win32yank</a></p>
<ul>
<li>以下、vimでコピー&amp;ペーストを行うために<br>win32yankはコマンドベースの、レジスタに文字列を登録することのできるWindowsで使えるものだ。UNIX系のXディスプレイだと、<code>x-clip</code>やWayLandディスプレイだと、<code>wl-copy</code>などがある。</li>
</ul>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/git/dotfiles/.global/bin/ <span class="comment"># 配置場所は任意</span></span><br><span class="line"><span class="built_in">wget</span> https://github.com/equalsraf/win32yank/releases/download/v0.<span class="number">1.1</span>/win32yank<span class="literal">-x64</span>.zip</span><br><span class="line">unzip .\win32yank<span class="literal">-x64</span>.zip</span><br><span class="line"><span class="built_in">Remove-Item</span> .\LICENSE, .\README.md, .\win32yank<span class="literal">-x64</span>.zip</span><br></pre></td></tr></table></figure>
<p>別途、<code>exe</code>ファイルの入ったフォルダをユーザー環境変数にセットしておこう。なお、今回は、WSLないないだが、WSLありきの環境で使う場合は、<code>.exe</code>実行ファイルの入ったフォルダをWSLのディストロ内で環境変数のパスに通す必要がある。</p>
<h3 id="ターミナルフォントを設定"><a href="#ターミナルフォントを設定" class="headerlink" title="ターミナルフォントを設定"></a>ターミナルフォントを設定</h3><p>私は、NerdFontが良いと思う。<br>nvimの<code>nvim-web-devicons</code>プラグインでも使える。<br><a href="https://www.nerdfonts.com/">https://www.nerdfonts.com/</a></p>
<p>Agave.zipなどをダウンロード<br>エクスプローラーから展開して、フォント群(ttfなど)を選択、インストール<br>ターミナルプロファイルより適用</p>
<h3 id="ターミナルキーマップを設定"><a href="#ターミナルキーマップを設定" class="headerlink" title="ターミナルキーマップを設定"></a>ターミナルキーマップを設定</h3><p>以下をターミナルプロファイルに追加。<br><code>Next tab</code>: <code>C-Shift-[</code><br><code>Previous tab</code>: <code>C-Shift-]</code><br><code>Split pane</code>: <code>C-Shift-Enter</code></p>
<h3 id="Neovimの設定"><a href="#Neovimの設定" class="headerlink" title="Neovimの設定"></a>Neovimの設定</h3><p>私の場合、Githubにその設定ファイルがあるので、それをインポートするだけで済む。<br>Neovimの設定ファイルは、<code>C:\Users\&lt;user&gt;\AppData\Local\</code>に配置しなければいけない。</p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmdなら</span></span><br><span class="line"><span class="built_in">cd</span> %LOCALAPPDATA%</span><br><span class="line"><span class="comment"># pwshなら</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$env:LOCALAPPDATA</span></span><br><span class="line"></span><br><span class="line">git clone https://github.com/verazza/nvim.git</span><br></pre></td></tr></table></figure>

<h3 id="Scala環境構築"><a href="#Scala環境構築" class="headerlink" title="Scala環境構築"></a>Scala環境構築</h3><p>まずは、<code>coursier</code>が使えるように、以下の記事に沿って、コマンドラインでインストールしていく。<br><a href="https://get-coursier.io/docs/cli-installation">https://get-coursier.io/docs/cli-installation</a></p>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PowerShell</span></span><br><span class="line"><span class="built_in">Invoke-WebRequest</span> <span class="literal">-Uri</span> <span class="string">&quot;https://github.com/coursier/launchers/raw/master/cs-x86_64-pc-win32.zip&quot;</span> <span class="literal">-OutFile</span> <span class="string">&quot;cs-x86_64-pc-win32.zip&quot;</span></span><br><span class="line"><span class="built_in">Expand-Archive</span> <span class="literal">-Path</span> <span class="string">&quot;cs-x86_64-pc-win32.zip&quot;</span> <span class="literal">-DestinationPath</span> .</span><br><span class="line"><span class="built_in">Rename-Item</span> <span class="literal">-Path</span> <span class="string">&quot;cs-x86_64-pc-win32.exe&quot;</span> <span class="literal">-NewName</span> <span class="string">&quot;cs.exe&quot;</span></span><br><span class="line"><span class="built_in">Remove-Item</span> <span class="literal">-Path</span> <span class="string">&quot;cs-x86_64-pc-win32.zip&quot;</span></span><br><span class="line">.\cs setup</span><br></pre></td></tr></table></figure>
<p>これで、<code>coursier</code>コマンドが使えると思いきや…<br>なぜか使えない。シェルを再起動しても使えなかった。<br>これの解決方法は、<code>.bat</code>をユーザー環境変数に通せばいい。</p>
<p>以下、私でないなら読み飛ばして構わない。</p>
<h2 id="シンボリックリンク作成"><a href="#シンボリックリンク作成" class="headerlink" title="シンボリックリンク作成"></a>シンボリックリンク作成</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="built_in">mkdir</span> -p git</span><br></pre></td></tr></table></figure>
<ul>
<li>cmd</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mklink /D nvim <span class="variable">%LOCALAPPDATA%</span>/nvim</span><br></pre></td></tr></table></figure>
<ul>
<li>pwsh</li>
</ul>
<figure class="highlight pwsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">New-Item</span> <span class="literal">-ItemType</span> Junction <span class="literal">-Path</span> <span class="string">&quot;nvim&quot;</span> <span class="literal">-Target</span> <span class="string">&quot;<span class="variable">$env:LOCALAPPDATA</span>\nvim&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Neovim, Windows, 開発環境</tag>
      </tags>
  </entry>
  <entry>
    <title>WSLを使う！ Windows開発環境構築</title>
    <url>/posts/17845/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h1 id="WSLありきのWindows開発環境構築"><a href="#WSLありきのWindows開発環境構築" class="headerlink" title="WSLありきのWindows開発環境構築"></a>WSLありきのWindows開発環境構築</h1><h2 id="コメント"><a href="#コメント" class="headerlink" title="コメント"></a>コメント</h2><p>この記事は、WSL導入とWSL-Archを使うまでのロードマップを知ることができる。また、WSLにArch導入後の開発環境構築には、通常のネイティブにブートすることを想定した<a href="https://verazza.github.io/posts/14653/">私的ArchLinux開発環境構築</a>の内容を含む。</p>
<p>ということで、まずは、WSLを使えるようにしていく。</p>
<h2 id="WSLの導入"><a href="#WSLの導入" class="headerlink" title="WSLの導入"></a>WSLの導入</h2><p>コントロールパネル＞プログラム＞プログラムと機能＞Windowsの機能の有効化または無効化より、Linux用Windowsサブシステム/仮想マシンプラットフォームにチェックを入れ、Windowsを再起動しよう。<br>再起動後には、コマンドラインでwslコマンドが使えるようになっているはずだ。</p>
<h2 id="WSLのディストロ選び"><a href="#WSLのディストロ選び" class="headerlink" title="WSLのディストロ選び"></a>WSLのディストロ選び</h2><p>今回は、私の普段開発で、またはサーバー機として、愛用しているArchLinuxをWSLで使うものとしよう。他のディストロを探したい場合は、以下を実行すると、WSLで使えるディストロを知ることができる。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure>


<h2 id="WSLでArchを使うまで"><a href="#WSLでArchを使うまで" class="headerlink" title="WSLでArchを使うまで"></a>WSLでArchを使うまで</h2><h3 id="インポートする方法3選"><a href="#インポートする方法3選" class="headerlink" title="インポートする方法3選"></a>インポートする方法3選</h3><p>先に、TARBALLの説明をしておく。<br>TARBALLとは、&#x2F;etc, &#x2F;homeなどLinuxの設定ファイルを含む、Linuxディストリビューションを構成する様々なファイルやディレクトリをまとめた圧縮ファイルのことだ。なお、カーネルは含まない。<br>（1）TARBALLをインストールして、任意に、必要ファイルを編集し、再圧縮をかけることで、WSLにインポートする方法<br>（2）ArchLinux公式が提供しているもので、すでに、インポート形式に特化した.wslファイルを落としてきて、それをインポートする方法。これはファイルを編集する手間がないので早い<br><a href="https://wiki.archlinux.org/title/Install_Arch_Linux_on_WSL">https://wiki.archlinux.org/title/Install_Arch_Linux_on_WSL</a><br>（3）ArchWSLという名前のGitプロジェクトで、これはArch.exeを管理者権限で実行するだけで、インポートが完了する方法。これは、サードパーティ製のツールにあたる。<br><a href="https://github.com/yuk7/ArchWSL">https://github.com/yuk7/ArchWSL</a></p>
<p>今回は、ArchLinuxを使うために、(1)を紹介するが、私は、(1)をした結果、やっぱり、(2)の方が簡単だと思った。だから、(2)の方が好みだし、推奨する。</p>
<h3 id="手順（2）"><a href="#手順（2）" class="headerlink" title="手順（2）"></a>手順（2）</h3><h4 id="Ubuntuのインストール"><a href="#Ubuntuのインストール" class="headerlink" title="Ubuntuのインストール"></a>Ubuntuのインストール</h4><p>まずは、Ubuntuをインストールしよう。<br>あれ、Archじゃないのと思った人はいるかとは思うが、次の手順のTARBALLを解凍したり、圧縮したりするのは、やっぱりLinuxでやったほうがいいと思うのだ…。（Windowsでやる方法を知らない勢）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --install -d Ubuntu</span><br></pre></td></tr></table></figure>
<h4 id="Ubuntuターミナルに入る"><a href="#Ubuntuターミナルに入る" class="headerlink" title="Ubuntuターミナルに入る"></a>Ubuntuターミナルに入る</h4><p>インストールが完了したら、以下のコマンドでUbuntuターミナルに入ろう。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -d Ubuntu</span><br></pre></td></tr></table></figure>

<h4 id="TARBALLのインストール"><a href="#TARBALLのインストール" class="headerlink" title="TARBALLのインストール"></a>TARBALLのインストール</h4><p>ArchLinuxのTARBALLを配信しているミラーサーバーは色々あるが、今回は以下を使用する。<br><a href="http://ftp.tsukuba.wide.ad.jp/Linux/archlinux/iso/">http://ftp.tsukuba.wide.ad.jp/Linux/archlinux/iso/</a></p>
<p>ここで、注意なのが、WSLは、<code>/mnt/c</code>よりCドライブをマウントするのがデフォだが、間違っても、以下の作業を、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /mnt/c/path/to/work</span><br><span class="line">tar ....</span><br></pre></td></tr></table></figure>
<p>などと、Ubuntuターミナルの中で、Cドライブにアクセスすることは避けよう。私も最初は、そうしたが、そうでないときと比べて、TARBALLの解凍および圧縮がとてつもなく遅かったのだ。</p>
<p>それを吟味して、以下、<code>wget</code>コマンドを使用して、最新のTARBALLを落としてこよう。<code>archlinux-bootstrap-2025.03.01-x86_64.tar.zst</code>の部分は、各自、最新のものを上のミラーサーバーからリンクをコピーして読み替えてほしい。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://ftp.tsukuba.wide.ad.jp/Linux/archlinux/iso/2025.03.01/archlinux-bootstrap-2025.03.01-x86_64.tar.zst</span><br></pre></td></tr></table></figure>

<h4 id="TARBALLの解凍-圧縮-再圧縮"><a href="#TARBALLの解凍-圧縮-再圧縮" class="headerlink" title="TARBALLの解凍&#x2F;圧縮&#x2F;再圧縮"></a>TARBALLの解凍&#x2F;圧縮&#x2F;再圧縮</h4><p>次に、<code>.tar.zst</code>ファイルを解凍するため、<code>zstd</code>パッケージをインストールする。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install zstd</span><br></pre></td></tr></table></figure>
<p>そして、TARBALLの解凍、必要ファイル編集、再圧縮を行う。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzstd archlinux-bootstrap-2025.03.01-x86_64.tar.zst</span><br><span class="line"></span><br><span class="line">tar -xvf archlinux-bootstrap-2025.03.01-x86_64.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> root.x86_64/</span><br><span class="line"><span class="comment"># Japan以下をコメントアウト</span></span><br><span class="line">nano etc/pacman.d/mirrorlist</span><br><span class="line"></span><br><span class="line"><span class="comment"># TARBALLの再圧縮 </span></span><br><span class="line">tar -czvf root.tar.gz *</span><br><span class="line"></span><br><span class="line"><span class="comment"># wslにマウントされているWindowsのCドライブにarchフォルダを作成。</span></span><br><span class="line"><span class="comment"># 別に、エクスプローラーからC:\wsl\archを作っても構わない。</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/c/wsl/arch</span><br><span class="line"><span class="built_in">cp</span> root.tar.gz /mnt/c/wsl/arch</span><br></pre></td></tr></table></figure>

<h4 id="WSLにインポート"><a href="#WSLにインポート" class="headerlink" title="WSLにインポート"></a>WSLにインポート</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --import ArchLinux C:\wsl\arch C:\wsl\arch\root.tar.gz</span><br><span class="line"># 確認</span><br><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>

<h2 id="WSL2にアップデート"><a href="#WSL2にアップデート" class="headerlink" title="WSL2にアップデート"></a>WSL2にアップデート</h2><p>もしかしたら、インストールしてきたディストロがWSL2で実行されていないかもしれない。特に、GUIアプリケーションをディストロ内で実行し、それをWindows側でディスプレイとして閲覧したい場合は、WSL2にアップデートするのがおすすめだ。ちなみに、その機能を<code>WSLg</code>という。<br>以下のコマンドで、WSL2になっているかが確認できる。各ディストロの<code>VERSION</code>の箇所が<code>2</code>になっていれば、OKだ。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br><span class="line"><span class="comment"># VERSIONが2になっていなかったら</span></span><br><span class="line"><span class="comment"># アップデート前にすべて停止させておく</span></span><br><span class="line">wsl --shutdown</span><br><span class="line">wsl --update</span><br><span class="line">wsl --set-default-version 2</span><br><span class="line"><span class="comment"># これらを実行し、再度</span></span><br><span class="line">wsl -l -v</span><br><span class="line"><span class="comment"># 2になっているはず。</span></span><br></pre></td></tr></table></figure>

<h2 id="wsl-confの作成"><a href="#wsl-confの作成" class="headerlink" title="wsl.confの作成"></a><code>wsl.conf</code>の作成</h2><p><code>/etc/wsl.conf</code>に配置しよう。<br>設定方法は様々だが、例として以下を紹介する。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">default=verazza</span><br><span class="line"></span><br><span class="line">[boot]</span><br><span class="line">systemd = true</span><br><span class="line">initTimeout = 1000</span><br><span class="line"></span><br><span class="line">[automount]</span><br><span class="line">enable = true</span><br><span class="line">options = &quot;metadata&quot;</span><br><span class="line">mountFsTab = true</span><br><span class="line"></span><br><span class="line">[wsl2]</span><br><span class="line">localhostForwarding = true</span><br><span class="line">memory = 11GB</span><br><span class="line"></span><br><span class="line">[interop]</span><br><span class="line">appendWindowsPath = false</span><br></pre></td></tr></table></figure>
<p>おそらく一番重要なのは、<code>boot.systemd</code>と<code>interop.appendWindowsPath</code>のキーだと思う。<code>appendWindowsPath</code>は、Windowsの環境変数をWSLのディストロでも引き継ぐかどうか決められる。これを<code>true</code>にすると、起動が遅かったりするので、私は<code>false</code>にしてる。また、<code>boot.initTimeout</code>は起動を早めるが少々注意が必要。詳しくは、以下を参照。<br><a href="https://learn.microsoft.com/ja-jp/windows/wsl/wsl-config#wslconf">https://learn.microsoft.com/ja-jp/windows/wsl/wsl-config#wslconf</a></p>
<h2 id="wslconfigの作成"><a href="#wslconfigの作成" class="headerlink" title=".wslconfigの作成"></a><code>.wslconfig</code>の作成</h2><p>これは、<code>C:\Users\&lt;user&gt;\.wslconfig</code>に配置しよう。<br>以下、例として</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">guiApplications = true</span><br><span class="line">kernelCommandLine = cgroup_no_v1=all</span><br></pre></td></tr></table></figure>
<p>主に、ディストロ内で実行されたGUIアプリケーションをWindows側のディスプレイで見るための設定だ。詳しくは、以下を参照。<br><a href="https://learn.microsoft.com/ja-jp/windows/wsl/wsl-config#wslconfig">https://learn.microsoft.com/ja-jp/windows/wsl/wsl-config#wslconfig</a></p>
<h2 id="WSLにArchインポート後"><a href="#WSLにArchインポート後" class="headerlink" title="WSLにArchインポート後"></a>WSLにArchインポート後</h2><p>ここからは、WSL-Archでの開発環境構築を行う。<br>ほとんどネイティブにArchをブートしているときに実行するものと大差ない。ということで、それは別記事に書こうと思う。<a href="https://verazza.github.io/posts/14653/">私的ArchLinux開発環境構築</a>を見てほしい。また、各種WSLディストロのソフトウェアを利用中に、クリップボードにコピーしたければ、<a href="https://verazza.github.io/posts/47392/#win32yank">win32yankについて</a>を参照してほしい。</p>
<h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>WSLはとてもいいと思います。第一に、メインOSが荒れないし、第二に、エクスポート・インポートも容易にできる。正直、実機で色々なOSを試してきた身としては、WSLの凄みにもう少し早く気づきたかったですね。</p>
<h2 id="WSLの高みに近づくために"><a href="#WSLの高みに近づくために" class="headerlink" title="WSLの高みに近づくために"></a>WSLの高みに近づくために</h2><p>例えば、完全なデスクトップ環境をWSLのディストロでも作れるんじゃないかと考える人もいると思う。私もその一人だ。実際に以下を試してみたが、WSL-Ubuntuで、ほんとうにGnomeデスクトップが立ち上がった。<br><a href="https://gist.github.com/tdcosta100/7def60bccc8ae32cf9cacb41064b1c0f">https://gist.github.com/tdcosta100/7def60bccc8ae32cf9cacb41064b1c0f</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zenn.dev/kyoh86/articles/4bf6513aabe517">https://zenn.dev/kyoh86/articles/4bf6513aabe517</a><br><a href="https://blog.yukirii.dev/wsl2-arch-linux/">https://blog.yukirii.dev/wsl2-arch-linux/</a><br><a href="https://zenn.dev/artemit/articles/63e073d53179ae">https://zenn.dev/artemit/articles/63e073d53179ae</a></p>
]]></content>
      <tags>
        <tag>Neovim, Windows, WSL, 開発環境</tag>
      </tags>
  </entry>
  <entry>
    <title>Github:glyzerレポジトリを立ち上げるまで</title>
    <url>/posts/33934/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h2 id="回顧録"><a href="#回顧録" class="headerlink" title="回顧録"></a>回顧録</h2><p>ある日、CLI環境を構築する際に、新たなTUI（ターミナルインターフェース）アプリが必要だなと感じた。<br>それは、ChatGPTやGeminiに代表されるAI-Chatアプリだ。それらがターミナルから使えればいいなと思ったのが事の始まりである。<br>そこでgemini-cliというものを知り、GeminiAPIKeyが必要になることを知る。そこからGeminiAPIに興味を持ち、手始めにpythonに接続することで、広範囲の分析が可能になることを知った。<br>これより、プロジェクト<a href="https://github.com/verazza/glyzer">glyzer</a>の始まりである。</p>
<h2 id="インストール"><a href="#インストール" class="headerlink" title="インストール"></a>インストール</h2><p><a href="https://github.com/eliben/gemini-cli">eliben&#x2F;gemini-cli</a></p>
<h2 id="このプロジェクトの理想"><a href="#このプロジェクトの理想" class="headerlink" title="このプロジェクトの理想"></a>このプロジェクトの理想</h2><p>Neovimでの開発中に、特定のキーマップより(<code>&lt;leader&gt;gm</code>など)現在のファイルに対して、geminiと応答を図る。また、入力でディレクトリパスを指定して、その中の指定拡張子よりdbファイルにまとめ、それをソースに、触媒に、栄養にし、応答を図る。<br>2つの環境の類似性より、分析を依頼する。</p>
<h2 id="gemini-cliに関するコマンド"><a href="#gemini-cliに関するコマンド" class="headerlink" title="gemini-cliに関するコマンド"></a>gemini-cliに関するコマンド</h2><ul>
<li>ファイル群をdbファイル形式にする<br>これはgeminiが食う。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gemini-cli embed db out.db --files .,*.py</span><br><span class="line"></span><br><span class="line">gemini-cli embed db out.db --files-list question.txt</span><br></pre></td></tr></table></figure>
<p>PythonはあくまでGeminiAPIを使って、ソースを食わせる役割。別に言語は何でもいいと思う</p>
<h2 id="現在思考中のもの"><a href="#現在思考中のもの" class="headerlink" title="現在思考中のもの"></a>現在思考中のもの</h2><p>以下、<a href="https://github.com/verazza/Ai-Analyzer/blob/master/setup.py">glyzer:&#x2F;setup.py</a> の説明<br>gemini-cliコマンドより、検索対象となるコード、それに対する質問となるコード(平文でもコードとみなす)に対して、それらいくつものファイル群を、数値ベクトル・埋め込みベクトルに変換(dbファイルにあたる)したものを、NumPy配列に変換する。単にdbファイルにエクスポートし、数値ベクトルにしても、それらは単なるバイナリデータに過ぎず、特定のデータ型・構造を持たないため、直接的に数値演算が可能になるNumPy配列に変換する必要がある。これにより、データを特定のデータ型(整数、不動小数点など)を持つ多次元配列として解釈できる。これより、コサイン類似性より比較する。コサイン類似度の高いコード片をソートし、出力する。また、その類似性よりわかったコードスニップより、geminiと応答する。</p>
<p>なぜデータベース(<code>*.db</code>)形式なのか。</p>
<ul>
<li>大量の埋め込みベクトルが効率的に保存・管理ができる</li>
<li>インデックス機能より検索が容易である</li>
<li>データベースを容易に持ち運び、共有できる</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>Gemini API Docs<br><a href="https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started.ipynb">https://github.com/google-gemini/cookbook/blob/main/quickstarts/Get_started.ipynb</a></li>
</ul>
]]></content>
      <tags>
        <tag>python, gemini</tag>
      </tags>
  </entry>
  <entry>
    <title>Website Terms and Policies</title>
    <url>/posts/41809/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>This post contains privacy policy and terms of service using at <a href="https://github.com/verazza/kishax-web">kishax-web</a>.</p>
<h2 id="Privacy-Policy"><a href="#Privacy-Policy" class="headerlink" title="Privacy Policy"></a>Privacy Policy</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last Updated: [2024/12/31]</span><br><span class="line"></span><br><span class="line">This Privacy Policy describes how we collect, use, and protect your personal information when you use our application (&quot;the App&quot;). By using the App, you agree to the practices described in this policy.</span><br><span class="line"></span><br><span class="line">1. Information We Collect</span><br><span class="line">We may collect the following information:</span><br><span class="line"></span><br><span class="line">Your X or Google username and profile information.</span><br><span class="line">Your email address (if you grant permission).</span><br><span class="line">2. How We Use Your Information</span><br><span class="line">The information we collect is used to:</span><br><span class="line"></span><br><span class="line">Authenticate your login to the App.</span><br><span class="line">Provide personalized services within the App.</span><br><span class="line">Contact you regarding important updates or changes to the App.</span><br><span class="line">3. Data Protection</span><br><span class="line">We are committed to protecting your personal information and use appropriate security measures to safeguard it.</span><br><span class="line"></span><br><span class="line">4. Third-Party Sharing</span><br><span class="line">We do not share your information with third parties except as required by law or necessary for the operation of the App.</span><br><span class="line"></span><br><span class="line">5. Contact Us</span><br><span class="line">If you have any questions about this Privacy Policy, please contact us at [maekawatakaya10.8@gmail.com].</span><br></pre></td></tr></table></figure>

<h2 id="Terms-Of-Service"><a href="#Terms-Of-Service" class="headerlink" title="Terms Of Service"></a>Terms Of Service</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Last Updated: [2024/12/31]</span><br><span class="line"></span><br><span class="line">These Terms of Service (&quot;Terms&quot;) govern your use of our application (&quot;the App&quot;). By accessing or using the App, you agree to comply with these Terms.</span><br><span class="line"></span><br><span class="line">1. Acceptable Use</span><br><span class="line">You must use the App in compliance with all applicable laws and regulations.</span><br><span class="line">You are responsible for any content you create or upload to the App.</span><br><span class="line">2. Prohibited Actions</span><br><span class="line">You may not:</span><br><span class="line"></span><br><span class="line">Use the App for any unlawful activities.</span><br><span class="line">Attempt to reverse-engineer or interfere with the App&#x27;s functionality.</span><br><span class="line">3. Limitation of Liability</span><br><span class="line">We are not responsible for any damages or losses resulting from your use of the App.</span><br><span class="line"></span><br><span class="line">4. Termination</span><br><span class="line">We reserve the right to suspend or terminate your access to the App for violations of these Terms.</span><br><span class="line"></span><br><span class="line">5. Changes to the Terms</span><br><span class="line">We may update these Terms from time to time. Continued use of the App constitutes acceptance of the updated Terms.</span><br><span class="line"></span><br><span class="line">6. Contact Us</span><br><span class="line">If you have any questions about these Terms, please contact us at [maekawatakaya10.8@gmail.com].</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>google,x</tag>
      </tags>
  </entry>
  <entry>
    <title>私的ArchLinux開発環境構築</title>
    <url>/posts/14653/</url>
    <content><![CDATA[<!--
Copyright (c) 2025 verazza
This file is distributed under the terms of the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
See the LICENSE file in the source directory for details.
(https://creativecommons.org/licenses/by-nc-sa/4.0/)
-->

<h1 id="ArchLinux開発環境構築"><a href="#ArchLinux開発環境構築" class="headerlink" title="ArchLinux開発環境構築"></a>ArchLinux開発環境構築</h1><h2 id="コメント"><a href="#コメント" class="headerlink" title="コメント"></a>コメント</h2><p>以下の記事はとても長い。<br>なので、Dockerを使った、<a href="https://github.com/verazza/devkit">devkit</a> によるコマンド一発で、私と同じ環境が作れるものを開発した。なお、ディストロ全体の容量は10GBほど。以下は、ほぼほぼdevkitの <a href="https://github.com/verazza/devkit/blob/master/Dockerfile">Dockerfile</a> に記述している内容と同じである。</p>
<h2 id="開発環境構築"><a href="#開発環境構築" class="headerlink" title="開発環境構築"></a>開発環境構築</h2><h3 id="ネット確認"><a href="#ネット確認" class="headerlink" title="ネット確認"></a>ネット確認</h3><p>応答があれば、ネットにつながっている。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure>

<h3 id="Localeの設定"><a href="#Localeの設定" class="headerlink" title="Localeの設定"></a>Localeの設定</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/locale.gen、最上行に追加</span></span><br><span class="line"><span class="built_in">tee</span> -a /etc/locale.gen &lt;&lt;<span class="string">EOL</span></span><br><span class="line"><span class="string">ja_JP.UTF-8 UTF-8</span></span><br><span class="line"><span class="string">en_US.UTF-8 UTF-8</span></span><br><span class="line"><span class="string">EOL</span></span><br><span class="line"></span><br><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<h2 id="もし、Localeエラーが出たら"><a href="#もし、Localeエラーが出たら" class="headerlink" title="もし、Localeエラーが出たら"></a>もし、Localeエラーが出たら</h2><p>en_US.UTF-8 UTF-8の行がコメントアウトされていないことを確認</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/locale.gen</span><br><span class="line"><span class="built_in">sudo</span> pacman -S glibc</span><br></pre></td></tr></table></figure>

<h3 id="Timezoneの設定"><a href="#Timezoneの設定" class="headerlink" title="Timezoneの設定"></a>Timezoneの設定</h3><p>現在のタイムゾーンを確認</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure>
<p>利用可能なタイムゾーンを一覧表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl list-timezones</span><br></pre></td></tr></table></figure>
<p>タイムゾーンを設定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> timedatectl set-timezone Asia/Tokyo</span><br></pre></td></tr></table></figure>

<h3 id="pacmanキーの初期化"><a href="#pacmanキーの初期化" class="headerlink" title="pacmanキーの初期化"></a><code>pacman</code>キーの初期化</h3><p><code>GnuPG</code>キーリングを初期化し、以降でダウンロードするパッケージが改ざんされていないことを確認し、開発者やメンテナーによって署名されたキーを使うことで、<code>pacman</code>が安全にパッケージを検証することができる。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman-key --init</span><br></pre></td></tr></table></figure>

<h3 id="ArchLinux公式キーの登録"><a href="#ArchLinux公式キーの登録" class="headerlink" title="ArchLinux公式キーの登録"></a>ArchLinux公式キーの登録</h3><p>Arch Linuxの公式パッケージメンテナーの公開鍵をキーリングに登録。これにより、公式リポジトリからダウンロードしたパッケージ署名を検証できる。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman-key --populate archlinux</span><br></pre></td></tr></table></figure>

<h3 id="基本パッケージと開発ツールのインストール"><a href="#基本パッケージと開発ツールのインストール" class="headerlink" title="基本パッケージと開発ツールのインストール"></a>基本パッケージと開発ツールのインストール</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syyu base base-devel git gvim wget unzip reflector go glibc</span><br></pre></td></tr></table></figure>
<p>一部、かいつまんで説明する。  </p>
<ul>
<li><code>base</code><br>最小限のArch Linuxシステムを構成するために必要な基本的なパッケージのグループ</li>
<li><code>base-devel</code><br>ソフトウェア開発に必要な基本的なツールが含まれるグループ（<code>gcc</code>, <code>make</code>, <code>binutils</code>など）</li>
<li><code>reflector</code><br>Arch Linuxのミラーサイトのリストを生成し、最適なミラーを選択するためのツール</li>
</ul>
<h3 id="システム全体のパッケージアップグレード"><a href="#システム全体のパッケージアップグレード" class="headerlink" title="システム全体のパッケージアップグレード"></a>システム全体のパッケージアップグレード</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>

<h3 id="ユーザー作成およびパスワード設定"><a href="#ユーザー作成およびパスワード設定" class="headerlink" title="ユーザー作成およびパスワード設定"></a>ユーザー作成およびパスワード設定</h3><p>&lt;user&gt;となっているところは各自ユーザー名に置き換えてほしい</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rootパスワード設定</span></span><br><span class="line">passwd</span><br><span class="line">useradd -m -g <span class="built_in">users</span> -G wheel -s /bin/bash &lt;user&gt;</span><br><span class="line">passwd &lt;user&gt;</span><br><span class="line">pacman -S <span class="built_in">sudo</span></span><br><span class="line"><span class="comment"># wheelグループにNO PASSWDの全権限付与</span></span><br><span class="line"><span class="comment"># %wheel ALL=(ALL:ALL) NOPASSWD: ALLの行をコメントアウト</span></span><br><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure>

<h3 id="AURヘルパーのインストール"><a href="#AURヘルパーのインストール" class="headerlink" title="AURヘルパーのインストール"></a>AURヘルパーのインストール</h3><p>非公式レポジトリであるAUR専門のパッケージマネジャーをインストールする必要がある。今回は、<code>yay</code>を紹介するが、他にも、<code>paru</code>, <code>pikaur</code>, <code>aura</code>, <code>cower</code>などがある。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="built_in">cd</span> yay</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>

<h3 id="その他ソフトウェア"><a href="#その他ソフトウェア" class="headerlink" title="その他ソフトウェア"></a>その他ソフトウェア</h3><h4 id="インストール"><a href="#インストール" class="headerlink" title="インストール"></a>インストール</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S kitty starship w3m lazygit tree unzip neovim noto-fonts-cjk</span><br></pre></td></tr></table></figure>
<p>説明しよう。  </p>
<ul>
<li>neovim<br>私が愛用しているエディター、高性能、多機能、己と一緒に成長する最強のエディター</li>
<li>kitty<br>ターミナルエディター。画像も表示できる。キーマップも多彩。Waylandとの互換性が良い。</li>
<li>starship<br>プロンプトジェネレーター。あなたのターミナルを柔軟にカスタマイズできる。</li>
<li>w3m<br>ターミナルでのブラウジングが可能なTUI。kittyの<code>imagemagick</code>と組み合わせれば、ブラウジング中に画像も見れちゃう。</li>
<li>noto-fonts-cjk<br>日本語フォント。</li>
</ul>
<h3 id="pyenvによるpython環境構築"><a href="#pyenvによるpython環境構築" class="headerlink" title="pyenvによるpython環境構築"></a>pyenvによるpython環境構築</h3><h4 id="pyenvのインストール"><a href="#pyenvのインストール" class="headerlink" title="pyenvのインストール"></a>pyenvのインストール</h4><p>以下、pyenvで、tkが必要になることがあるため。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S tk pyenv</span><br></pre></td></tr></table></figure>

<h4 id="環境変数の設定"><a href="#環境変数の設定" class="headerlink" title="環境変数の設定"></a>環境変数の設定</h4><p>(既に設定している場合はスキップ)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必要な設定を追加</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init --path)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv virtualenv-init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<h4 id="適切なPythonバージョンをインストール"><a href="#適切なPythonバージョンをインストール" class="headerlink" title="適切なPythonバージョンをインストール"></a>適切なPythonバージョンをインストール</h4><p>例として、Python 3.10.12をインストールする。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python 3.10.12をインストール</span></span><br><span class="line">pyenv install 3.10.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># グローバルにPython 3.10.12を使用するように設定</span></span><br><span class="line">pyenv global 3.10.12</span><br></pre></td></tr></table></figure>

<h4 id="確認"><a href="#確認" class="headerlink" title="確認"></a>確認</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Pythonバージョンを確認</span></span><br><span class="line">python --version</span><br></pre></td></tr></table></figure>
<p>詳しくは、以下を参照。<br><a href="https://github.com/pyenv/pyenv?tab=readme-ov-file#installation">https://github.com/pyenv/pyenv?tab=readme-ov-file#installation</a></p>
<h3 id="rustupのインストール"><a href="#rustupのインストール" class="headerlink" title="rustupのインストール"></a>rustupのインストール</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br></pre></td></tr></table></figure>
<p>詳しくは、以下を参照。<br><a href="https://www.rust-lang.org/ja/tools/install">https://www.rust-lang.org/ja/tools/install</a></p>
<h3 id="dockerのインストール"><a href="#dockerのインストール" class="headerlink" title="dockerのインストール"></a>dockerのインストール</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S docker docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="githubシークレットサービス"><a href="#githubシークレットサービス" class="headerlink" title="githubシークレットサービス"></a>githubシークレットサービス</h3><p><code>git-credential-manager</code>を使用すると、Gitでのリモートへのプッシュ時に、ブラウザによるログイン認証が行われる。<br>私は以下に書いてある内容を環境毎に入力するのが面倒だったので、専用のbashファイルを作って、実行するようにしてます。<br>興味のある方は、<a href="https://github.com/verazza/dotfiles/blob/master/.global/bin/gauth">verazza&#x2F;dotfiles:&#x2F;.global&#x2F;bin&#x2F;gauth</a> を見てみてください。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Syu git-credential-manager-core-extras</span><br><span class="line">git config --global credential.helper <span class="string">&#x27;manager&#x27;</span></span><br><span class="line">git config --global credential.credentialStore secretservice</span><br></pre></td></tr></table></figure>
<p>名前とメールアドレスを登録してなかったら以下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;you@example.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure>
<p>各レポジトリでHTTPS URLになっていることを確認<br>なっていなかったら、</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url origin https://github.com/username/repo.git</span><br></pre></td></tr></table></figure>

<h3 id="java-scala環境構築"><a href="#java-scala環境構築" class="headerlink" title="java/scala環境構築"></a>java/scala環境構築</h3><p>どちらも<a href="https://sdkman.io/">sdkman</a>を使用してセットアップしていく。<br>まずは、java環境を作る。<br>例として、oracle製のjava17をインストールする。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -s &quot;https://get.sdkman.io&quot; | bash</span><br><span class="line">source ~/.sdkman/bin/sdkman-init.sh</span><br><span class="line">sdk install java 17.0.12-oracle</span><br></pre></td></tr></table></figure>
<p>なお、別のjavaバージョンが知りたい場合は、以下を実行して、見ることができる。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdk list java</span><br></pre></td></tr></table></figure>
<p>次に、javaの後継と言われているあの言語、scala環境を作る。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&quot;https://get.sdkman.io&quot;</span> | bash</span><br><span class="line"><span class="built_in">source</span> ~/.sdkman/bin/sdkman-init.sh</span><br><span class="line">sdk install sbt</span><br><span class="line">yay -S coursier</span><br><span class="line">coursier setup -y</span><br><span class="line">coursier install metals</span><br></pre></td></tr></table></figure>
<p><code>coursier</code>と<code>metals</code>は、Neovimの<a href="https://github.com/scalameta/nvim-metals">scalameta&#x2F;nvim-metals</a>プラグインで使う。</p>
<h3 id="Neovimの設定"><a href="#Neovimの設定" class="headerlink" title="Neovimの設定"></a>Neovimの設定</h3><p>以下の私のNeovimの設定レポジトリを紹介する。ぜひ見てほしい。<br><a href="https://github.com/verazza/nvim">https://github.com/verazza/nvim</a></p>
<h3 id="kittyの設定"><a href="#kittyの設定" class="headerlink" title="kittyの設定"></a>kittyの設定</h3><h4 id="w3mでブラウジング中に画像を表示するための設定"><a href="#w3mでブラウジング中に画像を表示するための設定" class="headerlink" title="w3mでブラウジング中に画像を表示するための設定"></a>w3mでブラウジング中に画像を表示するための設定</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S imagemagick</span><br></pre></td></tr></table></figure>
<p>あとは、w3mの設定ファイルを変更する。<br><code>~/.w3m/config</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">inline_image_protocol 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>これで、インライン画像方式がkitty(ImageMagick)を使うものになる。</p>
<h3 id="nvmによるnpm-node環境構築"><a href="#nvmによるnpm-node環境構築" class="headerlink" title="nvmによるnpm/node環境構築"></a>nvmによるnpm/node環境構築</h3><p>例として、nvmバージョン<code>v0.40.2</code>で、nodeバージョン<code>22.12.0</code>をインストールする。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.2/install.sh | bash</span><br><span class="line">nvm install 22.12.0</span><br><span class="line">nvm use 22.12.0</span><br></pre></td></tr></table></figure>

<h3 id="dotfilesのインポート"><a href="#dotfilesのインポート" class="headerlink" title="dotfilesのインポート"></a>dotfilesのインポート</h3><p>私の環境では、設定ファイルはすべてGithubのレポジトリ: <a href="https://github.com/verazza/dotfiles">verazza&#x2F;dotfiles</a>にまとめているので、各ソフトウェアのドットファイルを移植するだけで済む。</p>
<h3 id="GUI環境の構築（任意）"><a href="#GUI環境の構築（任意）" class="headerlink" title="GUI環境の構築（任意）"></a>GUI環境の構築（任意）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S acpid xorg sddm plasma konsole</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure>
<p>私は、KDE PlasmaしかArchLinuxでは試したことないが、使いやすいと感じている。同時にダウンロードしておいたほうがいいものを紹介しよう。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S power-profiles-daemon</span><br></pre></td></tr></table></figure>
<p>これにより、GUI操作で電源モードをパフォーマンス・バランス・省電力に変更できる。</p>
<h2 id="最後に"><a href="#最後に" class="headerlink" title="最後に"></a>最後に</h2><p>書いてて思った、面倒だ！！！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zenn.dev/ytjvdcm/articles/0efb9112468de3">https://zenn.dev/ytjvdcm/articles/0efb9112468de3</a></p>
]]></content>
  </entry>
</search>
